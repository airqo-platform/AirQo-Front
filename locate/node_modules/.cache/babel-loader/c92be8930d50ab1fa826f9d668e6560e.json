{"ast":null,"code":"/* jshint node:true */\n'use strict';\n/**\n * Module dependencies.\n */\n\nconst EOL = require('../core/eol');\n\nconst joinRows = require('../core/join-rows');\n\nconst Handler = require('./handler');\n\nconst helper = require('../core/helper');\n\nclass Parser {\n  constructor(options) {\n    this._options = this._parseOptions(options) || {};\n    this._handler = new Handler(this._options);\n    this._headers = this._options.headers || [];\n    this._escape = require('../core/escape-delimiters')(this._options.textDelimiter, this._options.rowDelimiter, this._options.forceTextDelimiter);\n  }\n  /**\n   * Generates a CSV file with optional headers based on the passed JSON,\n   * with can be an Object or Array.\n   *\n   * @param {Object|Array} json\n   * @param {Function} done(err,csv) - Callback function\n   *      if error, returning error in call back.\n   *      if csv is created successfully, returning csv output to callback.\n   */\n\n\n  parse(json, done, stream) {\n    if (helper.isArray(json)) return done(null, this._parseArray(json, stream));else if (helper.isObject(json)) return done(null, this._parseObject(json));\n    return done(new Error('Unable to parse the JSON object, its not an Array or Object.'));\n  }\n\n  get headers() {\n    let headers = this._headers;\n    if (this._options.rename && this._options.rename.length > 0) headers = headers.map(header => this._options.rename[this._options.headers.indexOf(header)] || header);\n\n    if (this._options.forceTextDelimiter) {\n      headers = headers.map(header => {\n        return `${this._options.textDelimiter}${header}${this._options.textDelimiter}`;\n      });\n    }\n\n    if (this._options.mapHeaders) headers = headers.map(this._options.mapHeaders);\n    return headers.join(this._options.rowDelimiter);\n  }\n\n  _checkRows(rows) {\n    let lastRow = null;\n    let finalRows = [];\n\n    let fillGaps = (col, index) => col === '' || col === undefined ? lastRow[index] : col;\n\n    for (let row of rows) {\n      let missing = this._headers.length - row.length;\n      if (missing > 0) row = row.concat(Array(missing).join(\".\").split(\".\"));\n      if (lastRow && this._options.fillGaps) row = row.map(fillGaps);\n      finalRows.push(row.join(this._options.rowDelimiter));\n      lastRow = row;\n    }\n\n    return finalRows;\n  }\n\n  _parseArray(json, stream) {\n    let self = this;\n    this._headers = this._headers || [];\n    let fileRows = [];\n    let outputFile;\n    let fillRows;\n\n    let getHeaderIndex = function (header) {\n      var index = self._headers.indexOf(header);\n\n      if (index === -1) {\n        self._headers.push(header);\n\n        index = self._headers.indexOf(header);\n      }\n\n      return index;\n    }; //Generate the csv output\n\n\n    fillRows = function (result) {\n      const rows = [];\n\n      const fillAndPush = row => rows.push(row.map(col => col || '')); // initialize the array with empty strings to handle 'unpopular' headers\n\n\n      const newRow = () => new Array(self._headers.length).fill(null);\n\n      const emptyRowIndexByHeader = {};\n      let currentRow = newRow();\n\n      for (let element of result) {\n        let elementHeaderIndex = getHeaderIndex(element.item);\n\n        if (currentRow[elementHeaderIndex] != undefined) {\n          fillAndPush(currentRow);\n          currentRow = newRow();\n        }\n\n        emptyRowIndexByHeader[elementHeaderIndex] = emptyRowIndexByHeader[elementHeaderIndex] || 0; // make sure there isnt a empty row for this header\n\n        if (emptyRowIndexByHeader[elementHeaderIndex] < rows.length) {\n          rows[emptyRowIndexByHeader[elementHeaderIndex]][elementHeaderIndex] = self._escape(element.value);\n          emptyRowIndexByHeader[elementHeaderIndex] += 1;\n          continue;\n        }\n\n        currentRow[elementHeaderIndex] = self._escape(element.value);\n        emptyRowIndexByHeader[elementHeaderIndex] += 1;\n      } // push last row\n\n\n      if (currentRow.length > 0) {\n        fillAndPush(currentRow);\n      }\n\n      fileRows = fileRows.concat(self._checkRows(rows));\n    };\n\n    for (let item of json) {\n      //Call checkType to list all items inside this object\n      //Items are returned as a object {item: 'Prop Value, Item Name', value: 'Prop Data Value'}\n      let itemResult = self._handler.check(item, self._options.mainPathItem, item, json);\n\n      fillRows(itemResult);\n    }\n\n    if (!stream && self._options.includeHeaders) {\n      //Add the headers to the first line\n      fileRows.unshift(this.headers);\n    }\n\n    return joinRows(fileRows, self._options.endOfLine);\n  }\n\n  _parseObject(json) {\n    let self = this;\n    let fileRows = [];\n    let parseResult = [];\n    let outputFile;\n    let fillRows;\n    let horizontalRows = [[], []];\n\n    fillRows = function (result) {\n      var value = result.value ? result.value.toString() : self._options.undefinedString;\n      value = self._escape(value); //Type header;value\n\n      if (self._options.verticalOutput) {\n        var row = [result.item, value];\n        fileRows.push(row.join(self._options.rowDelimiter));\n      } else {\n        horizontalRows[0].push(result.item);\n        horizontalRows[1].push(value);\n      }\n    };\n\n    for (var prop in json) {\n      var prefix = \"\";\n      if (this._options.mainPathItem) prefix = this._options.mainPathItem + this._options.headerPathString;\n      parseResult = this._handler.check(json[prop], prefix + prop, prop, json);\n      parseResult.forEach(fillRows);\n    }\n\n    if (!this._options.verticalOutput) {\n      fileRows.push(horizontalRows[0].join(this._options.rowDelimiter));\n      fileRows.push(horizontalRows[1].join(this._options.rowDelimiter));\n    }\n\n    return joinRows(fileRows, this._options.endOfLine);\n  }\n  /**\n   * Replaces the default options with the custom user options\n   *\n   * @param {Options} userOptions\n   */\n\n\n  _parseOptions(userOptions) {\n    let defaultOptions = {\n      headers: [],\n      //              Array\n      rename: [],\n      //               Array\n      headerPathString: '.',\n      //    String\n      rowDelimiter: ',',\n      //        String\n      textDelimiter: '\"',\n      //       String\n      arrayPathString: ';',\n      //     String\n      undefinedString: '',\n      //      String\n      endOfLine: EOL || '\\n',\n      //   String\n      mainPathItem: null,\n      //       String\n      booleanTrueString: null,\n      //  String\n      booleanFalseString: null,\n      // String\n      includeHeaders: true,\n      //     Boolean\n      fillGaps: false,\n      //          Boolean\n      verticalOutput: true,\n      //     Boolean\n      forceTextDelimiter: false,\n      //Boolean\n      //Handlers\n      handleString: undefined,\n      //  Function\n      handleNumber: undefined,\n      //  Function\n      handleBoolean: undefined,\n      // Function\n      handleDate: undefined //    Function\n\n    };\n    return Object.assign({}, defaultOptions, userOptions);\n  }\n\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/User/Documents/Projects/AirQo-frontend/locate/node_modules/jsonexport/lib/parser/csv.js"],"names":["EOL","require","joinRows","Handler","helper","Parser","constructor","options","_options","_parseOptions","_handler","_headers","headers","_escape","textDelimiter","rowDelimiter","forceTextDelimiter","parse","json","done","stream","isArray","_parseArray","isObject","_parseObject","Error","rename","length","map","header","indexOf","mapHeaders","join","_checkRows","rows","lastRow","finalRows","fillGaps","col","index","undefined","row","missing","concat","Array","split","push","self","fileRows","outputFile","fillRows","getHeaderIndex","result","fillAndPush","newRow","fill","emptyRowIndexByHeader","currentRow","element","elementHeaderIndex","item","value","itemResult","check","mainPathItem","includeHeaders","unshift","endOfLine","parseResult","horizontalRows","toString","undefinedString","verticalOutput","prop","prefix","headerPathString","forEach","userOptions","defaultOptions","arrayPathString","booleanTrueString","booleanFalseString","handleString","handleNumber","handleBoolean","handleDate","Object","assign","module","exports"],"mappings":"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","sourcesContent":["/* jshint node:true */\n'use strict';\n\n/**\n * Module dependencies.\n */\nconst EOL = require('../core/eol')\nconst joinRows = require('../core/join-rows');\nconst Handler = require('./handler');\nconst helper = require('../core/helper');\n\nclass Parser {\n  constructor(options) {\n    this._options = this._parseOptions(options) || {};\n    this._handler = new Handler(this._options);\n    this._headers = this._options.headers || [];\n    this._escape = require('../core/escape-delimiters')(\n      this._options.textDelimiter,\n      this._options.rowDelimiter,\n      this._options.forceTextDelimiter\n    );\n  }\n\n  /**\n   * Generates a CSV file with optional headers based on the passed JSON,\n   * with can be an Object or Array.\n   *\n   * @param {Object|Array} json\n   * @param {Function} done(err,csv) - Callback function\n   *      if error, returning error in call back.\n   *      if csv is created successfully, returning csv output to callback.\n   */\n  parse(json, done, stream) {\n    if (helper.isArray(json)) return done(null, this._parseArray(json, stream));\n    else if (helper.isObject(json)) return done(null, this._parseObject(json));\n    return done(new Error('Unable to parse the JSON object, its not an Array or Object.'));\n  }\n\n  get headers() {\n    let headers = this._headers;\n\n    if (this._options.rename && this._options.rename.length > 0)\n      headers = headers.map((header) => this._options.rename[this._options.headers.indexOf(header)] || header);\n      \n    if (this._options.forceTextDelimiter) {\n      headers = headers.map((header) => {\n        return `${this._options.textDelimiter}${header}${this._options.textDelimiter}`;\n      });\n    }\n\n    if (this._options.mapHeaders)\n      headers = headers.map(this._options.mapHeaders);\n\n    return headers.join(this._options.rowDelimiter);\n  }\n\n  _checkRows(rows) {\n    let lastRow = null;\n    let finalRows = [];\n    let fillGaps = (col, index) => col === '' || col === undefined ? lastRow[index] : col;\n    for (let row of rows) {\n      let missing = this._headers.length - row.length;\n      if (missing > 0) row = row.concat(Array(missing).join(\".\").split(\".\"));\n      if (lastRow && this._options.fillGaps) row = row.map(fillGaps);\n      finalRows.push(row.join(this._options.rowDelimiter));\n      lastRow = row;\n    }\n    return finalRows;\n  }\n\n  _parseArray(json, stream) {\n    let self = this;\n    this._headers = this._headers || [];\n    let fileRows = [];\n    let outputFile;\n    let fillRows;\n\n    let getHeaderIndex = function(header) {\n      var index = self._headers.indexOf(header);\n      if (index === -1) {\n        self._headers.push(header);\n        index = self._headers.indexOf(header);\n      }\n      return index;\n    };\n\n    //Generate the csv output\n    fillRows = function(result) {\n      const rows = [];\n      const fillAndPush = (row) => rows.push(row.map(col => col || ''));\n      // initialize the array with empty strings to handle 'unpopular' headers\n      const newRow = () => new Array(self._headers.length).fill(null);\n      const emptyRowIndexByHeader = {};\n      let currentRow = newRow();\n      for (let element of result) {\n        let elementHeaderIndex = getHeaderIndex(element.item);\n        if (currentRow[elementHeaderIndex] != undefined) {\n          fillAndPush(currentRow);\n          currentRow = newRow();\n        }\n        emptyRowIndexByHeader[elementHeaderIndex] = emptyRowIndexByHeader[elementHeaderIndex] || 0;\n        // make sure there isnt a empty row for this header\n        if (emptyRowIndexByHeader[elementHeaderIndex] < rows.length) {\n          rows[emptyRowIndexByHeader[elementHeaderIndex]][elementHeaderIndex] = self._escape(element.value);\n          emptyRowIndexByHeader[elementHeaderIndex] += 1;\n          continue;\n        }\n        currentRow[elementHeaderIndex] = self._escape(element.value);\n        emptyRowIndexByHeader[elementHeaderIndex] += 1;\n      }\n      // push last row\n      if (currentRow.length > 0) {\n        fillAndPush(currentRow);\n      }\n      fileRows = fileRows.concat(self._checkRows(rows));\n    };\n    for (let item of json) {\n      //Call checkType to list all items inside this object\n      //Items are returned as a object {item: 'Prop Value, Item Name', value: 'Prop Data Value'}\n      let itemResult = self._handler.check(item, self._options.mainPathItem, item, json);\n      fillRows(itemResult);\n    }\n\n    if (!stream && self._options.includeHeaders) {\n      //Add the headers to the first line\n      fileRows.unshift(this.headers);\n    }\n\n    return joinRows(fileRows, self._options.endOfLine);\n  }\n\n  _parseObject(json) {\n    let self = this;\n    let fileRows = [];\n    let parseResult = [];\n    let outputFile;\n    let fillRows;\n    let horizontalRows = [\n      [],\n      []\n    ];\n\n    fillRows = function(result) {\n      var value = result.value ? result.value.toString() : self._options.undefinedString;\n      value = self._escape(value);\n\n      //Type header;value\n      if (self._options.verticalOutput) {\n        var row = [result.item, value];\n        fileRows.push(row.join(self._options.rowDelimiter));\n      } else {\n        horizontalRows[0].push(result.item);\n        horizontalRows[1].push(value);\n      }\n    };\n    for (var prop in json) {\n      var prefix = \"\";\n      if (this._options.mainPathItem)\n        prefix = this._options.mainPathItem + this._options.headerPathString;\n      parseResult = this._handler.check(json[prop], prefix + prop, prop, json);\n\n      parseResult.forEach(fillRows);\n    }\n    if (!this._options.verticalOutput) {\n      fileRows.push(horizontalRows[0].join(this._options.rowDelimiter));\n      fileRows.push(horizontalRows[1].join(this._options.rowDelimiter));\n    }\n    return joinRows(fileRows, this._options.endOfLine);\n  }\n\n  /**\n   * Replaces the default options with the custom user options\n   *\n   * @param {Options} userOptions\n   */\n  _parseOptions(userOptions) {\n    let defaultOptions = {\n      headers: [], //              Array\n      rename: [], //               Array\n      headerPathString: '.', //    String\n      rowDelimiter: ',', //        String\n      textDelimiter: '\"', //       String\n      arrayPathString: ';', //     String\n      undefinedString: '', //      String\n      endOfLine: EOL || '\\n', //   String\n      mainPathItem: null, //       String\n      booleanTrueString: null, //  String\n      booleanFalseString: null, // String\n      includeHeaders: true, //     Boolean\n      fillGaps: false, //          Boolean\n      verticalOutput: true, //     Boolean\n      forceTextDelimiter: false, //Boolean\n      //Handlers\n      handleString: undefined, //  Function\n      handleNumber: undefined, //  Function\n      handleBoolean: undefined, // Function\n      handleDate: undefined, //    Function\n    };\n    return Object.assign({}, defaultOptions, userOptions);\n  }\n}\n\nmodule.exports = Parser;"]},"metadata":{},"sourceType":"script"}